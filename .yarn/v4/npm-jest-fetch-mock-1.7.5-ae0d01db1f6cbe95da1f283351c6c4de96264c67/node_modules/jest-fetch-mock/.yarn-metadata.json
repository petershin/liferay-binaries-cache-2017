{
  "manifest": {
    "name": "jest-fetch-mock",
    "version": "1.7.5",
    "description": "fetch mock for jest",
    "main": "src/index.js",
    "types": "src/index.d.ts",
    "scripts": {
      "test": "jest"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/jefflau/jest-fetch-mock.git"
    },
    "keywords": [
      "jest",
      "mock",
      "fetch"
    ],
    "author": {
      "name": "Jeff Lau",
      "email": "jeff-lau@live.com",
      "url": "http://jefflau.net/"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/jefflau/jest-fetch-mock/issues"
    },
    "homepage": "https://github.com/jefflau/jest-fetch-mock#readme",
    "dependencies": {
      "cross-fetch": "^2.2.2",
      "promise-polyfill": "^7.1.1"
    },
    "devDependencies": {
      "babel-core": "^6.26.3",
      "babel-jest": "^23.4.2",
      "babel-preset-env": "^1.7.0",
      "jest": "^23.5.0",
      "regenerator-runtime": "^0.12.1"
    },
    "prettier": {
      "semi": false,
      "editor.formatOnSave": true,
      "singleQuote": true
    },
    "jest": {
      "automock": false,
      "setupFiles": [
        "./setupJest.js"
      ]
    },
    "_registry": "npm",
    "_loc": "..\\..\\liferay-binaries-cache-2017\\.yarn\\v4\\npm-jest-fetch-mock-1.7.5-ae0d01db1f6cbe95da1f283351c6c4de96264c67\\node_modules\\jest-fetch-mock\\package.json",
    "readmeFilename": "README.md",
    "readme": "# Jest Fetch Mock\n\nFetch is the new way to do HTTP requests in the browser, and it can be used in other environments such as React Native. Jest Fetch Mock allows you to easily mock your `fetch` calls and return the response you need to fake the HTTP requests. It's easy to setup and you don't need a library like `nock` to get going and it uses Jest's built-in support for mocking under the surface. This means that any of the `jest.fn()` methods are also available. For more information on the jest mock API, check their docs [here](https://facebook.github.io/jest/docs/en/mock-functions.html)\n\nIt currently supports the mocking with the [`cross-fetch`](https://www.npmjs.com/package/cross-fetch) polyfill, so it supports Node.js and any browser-like runtime.\n\n## Contents\n\n- [Usage](#usage)\n  - [Installation and Setup](#installation-and-setup)\n  - [Using with Create-React-App](#using-with-create-react-app)\n- [API](#api)\n- [Examples](#examples)\n  - [Simple mock and assert](#simple-mock-and-assert)\n  - [Mocking all fetches](#mocking-all-fetches)\n  - [Mocking a failed fetch](#mocking-a-failed-fetch)\n  - [Mocking multiple fetches with different responses](#mocking-multiple-fetches-with-different-responses)\n  - [Mocking multiple fetches with `fetch.mockResponses`](#mocking-multiple-fetches-with-fetchmockresponses)\n  - [Reset mocks between tests with `fetch.resetMocks`](#reset-mocks-between-tests-with-fetchresetmocks)\n  - [Using `fetch.mock` to inspect the mock state of each fetch call](#using-fetchmock-to-inspect-the-mock-state-of-each-fetch-call)\n\n## Usage\n\n### Installation and Setup\n\nTo setup your fetch mock you need to do the following things:\n\n```\n$ npm install --save-dev jest-fetch-mock\n```\n\nCreate a `setupJest` file to setup the mock or add this to an existing `setupFile`. :\n\n```js\n//setupJest.js or similar file\nglobal.fetch = require('jest-fetch-mock')\n```\n\nAdd the setupFile to your jest config in `package.json`:\n\n```JSON\n\"jest\": {\n  \"automock\": false,\n  \"setupFiles\": [\n    \"./setupJest.js\"\n  ]\n}\n```\n\n### Using with Create-React-App\n\nIf you are using [Create-React-App](https://github.com/facebookincubator/create-react-app) (CRA), the code for `setupTest.js` above should be placed into `src/setupTests.js` in the root of your project. CRA automatically uses this filename by convention in the Jest configuration it generates. Similarly, changing to your `package.json` is not required as CRA handles this when generating your Jest configuration.\n\n### For Ejected Create React Apps _ONLY_:\n\n> Note: Keep in mind that if you decide to \"eject\" before creating src/setupTests.js, the resulting package.json file won't contain any reference to it, so you should manually create the property setupTestFrameworkScriptFile in the configuration for Jest, something like the [following](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#srcsetuptestsjs-1):\n\n```JSON\n\"jest\": {\n  \"setupTestFrameworkScriptFile\": \"<rootDir>/src/setupTests.js\"\n }\n```\n\n## API\n\n### Mock Responses\n\n- `fetch.mockResponse(body, init): fetch` - Mock all fetch calls\n- `fetch.mockResponseOnce(body, init): fetch` - Mock each fetch call independently\n- `fetch.once(body, init): fetch` - Alias for mockResponseOnce\n- `fetch.mockResponses(...responses): fetch` - Mock multiple fetch calls independently\n  - Each argument is an array taking `[body, init]`\n- `fetch.mockReject(error): fetch` - Mock all fetch calls, letting them fail directly\n- `fetch.mockRejectOnce(error): fetch` - Let the next fetch call fail directly\n\n### Mock utilities\n\n- `fetch.resetMocks()` - Clear previously set mocks so they do not bleed into other mocks\n- `fetch.mock` - The mock state for your fetch calls. Make assertions on the arguments given to `fetch` when called by the functions you are testing. For more information check the [Jest docs](https://facebook.github.io/jest/docs/en/mock-functions.html#mock-property)\n\nFor information on the arguments body and init can take, you can look at the MDN docs on the Response Constructor function, which `jest-fetch-mock` uses under the surface.\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/Response/Response\n\nEach mocked response or err\nor will return a [Mock Function](http://facebook.github.io/jest/docs/mock-function-api.html#content). You can use methods like `.toHaveBeenCalledWith` to ensure that the mock function was called with specific arguments. For more methods detail, take a look at [this](http://facebook.github.io/jest/docs/expect.html#content).\n\n## Examples\n\nIn most of the complicated examples below, I am testing my action creators in Redux, but it doesn't have to be used with Redux.\n\n### Simple mock and assert\n\nIn this simple example I won't be using any libraries. It is a simple fetch request, in this case to google.com. First we setup the `beforeEach` callback to reset our mocks. This isn't strictly necessary in this example, but since we will probably be mocking fetch more than once, we need to reset it across our tests to assert on the arguments given to fetch.\n\nOnce we've done that we can start to mock our response. We want to give it an objectwith a `data` property and a string value of `12345` and wrap it in `JSON.stringify` to JSONify it. Here we use `mockResponseOnce`, but we could also use `once`, which is an alias.\n\nWe then call the function that we want to test with the arguments we want to test with. In the `then` callback we assert we have got the correct data back.\n\nFinally we can assert on the `.mock` state that Jest provides for us to test what arguments were given to fetch and how many times it was called\n\n```js\n//api.js\nexport function APIRequest(who) {\n  if (who === 'google') {\n    return fetch('https://google.com').then(res => res.json())\n  } else {\n    return 'no argument provided'\n  }\n}\n```\n\n```js\n//api.test.js\nimport { APIRequest } from './api'\n\ndescribe('testing api', () => {\n  beforeEach(() => {\n    fetch.resetMocks()\n  })\n\n  it('calls google and returns data to me', () => {\n    fetch.mockResponseOnce(JSON.stringify({ data: '12345' }))\n\n    //assert on the response\n    APIRequest('google').then(res => {\n      expect(res.data).toEqual('12345')\n    })\n\n    //assert on the times called and arguments given to fetch\n    expect(fetch.mock.calls.length).toEqual(1)\n    expect(fetch.mock.calls[0][0]).toEqual('https://google.com')\n  })\n})\n```\n\n### Mocking all fetches\n\nIn this example I am mocking just one fetch call. Any additional fetch calls in the same function will also have the same mock response. For more complicated functions with multiple fetch calls, you can check out example 3.\n\n```js\nimport configureMockStore from 'redux-mock-store' // mock store\nimport thunk from 'redux-thunk'\n\nconst middlewares = [thunk]\nconst mockStore = configureMockStore(middlewares)\n\nimport { getAccessToken } from './accessToken'\n\ndescribe('Access token action creators', () => {\n  it('dispatches the correct actions on successful fetch request', () => {\n    fetch.mockResponse(JSON.stringify({ access_token: '12345' }))\n\n    const expectedActions = [\n      { type: 'SET_ACCESS_TOKEN', token: { access_token: '12345' } }\n    ]\n    const store = mockStore({ config: { token: '' } })\n\n    return (\n      store\n        .dispatch(getAccessToken())\n        //getAccessToken contains the fetch call\n        .then(() => {\n          // return of async actions\n          expect(store.getActions()).toEqual(expectedActions)\n        })\n    )\n  })\n})\n```\n\n### Mocking a failed fetch\n\nIn this example I am mocking just one fetch call but this time using the `mockReject` function to simulate a failed request. Any additional fetch calls in the same function will also have the same mock response. For more complicated functions with multiple fetch calls, you can check out example 3.\n\n```js\nimport configureMockStore from 'redux-mock-store' // mock store\nimport thunk from 'redux-thunk'\n\nconst middlewares = [thunk]\nconst mockStore = configureMockStore(middlewares)\n\nimport { getAccessToken } from './accessToken'\n\ndescribe('Access token action creators', () => {\n  it('dispatches the correct actions on a failed fetch request', () => {\n    fetch.mockReject(new Error('fake error message'))\n\n    const expectedActions = [\n      { type: 'SET_ACCESS_TOKEN_FAILED', error: { status: 503 } }\n    ]\n    const store = mockStore({ config: { token: '' } })\n\n    return (\n      store\n        .dispatch(getAccessToken())\n        //getAccessToken contains the fetch call\n        .then(() => {\n          // return of async actions\n          expect(store.getActions()).toEqual(expectedActions)\n        })\n    )\n  })\n})\n```\n\n### Mocking multiple fetches with different responses\n\nIn this next example, the store does not yet have a token, so we make a request to get an access token first. This means that we need to mock two different responses, one for each of the fetches. Here we can use `fetch.mockResponseOnce` or `fetch.once` to mock the response only once and call it twice. Because we return the mocked function, we can chain this jQuery style. It internally uses Jest's `mockImplementationOnce`. You can read more about it on the [Jest documentation](https://facebook.github.io/jest/docs/mock-functions.html#content)\n\n```js\nimport configureMockStore from 'redux-mock-store'\nimport thunk from 'redux-thunk'\n\nconst middlewares = [thunk]\nconst mockStore = configureMockStore(middlewares)\n\nimport { getAnimeDetails } from './animeDetails'\n\ndescribe('Anime details action creators', () => {\n  it('dispatches requests for an access token before requesting for animeDetails', () => {\n    fetch\n      .once(JSON.stringify({ access_token: '12345' }))\n      .once(JSON.stringify({ name: 'naruto' }))\n\n    //once is an alias for .mockResponseOnce\n    //\n\n    const expectedActions = [\n      { type: 'SET_ACCESS_TOKEN', token: { access_token: '12345' } },\n      { type: 'SET_ANIME_DETAILS', animeDetails: { name: 'naruto' } }\n    ]\n    const store = mockStore({ config: { token: null } })\n\n    return (\n      store\n        .dispatch(getAnimeDetails('21049'))\n        //getAnimeDetails contains the 2 fetch calls\n        .then(() => {\n          // return of async actions\n          expect(store.getActions()).toEqual(expectedActions)\n        })\n    )\n  })\n})\n```\n\n### Mocking multiple fetches with `fetch.mockResponses`\n\n`fetch.mockResponses` takes as many arguments as you give it, all of which are arrays representing each Response Object. It will then call the `mockImplementationOnce` for each response object you give it. This reduces the amount of boilerplate code you need to write. An alternative is to use `.once` and chain it multiple times if you don't like wrapping each response arguments in a tuple/array.\n\nIn this example our actionCreator calls `fetch` 4 times, once for each season of the year and then concatenates the results into one final array. You'd have to write `fetch.mockResponseOnce` 4 times to achieve the same thing:\n\n```js\ndescribe('getYear action creator', () => {\n  it('dispatches the correct actions on successful getSeason fetch request', () => {\n    fetch.mockResponses(\n      [\n        JSON.stringify([{ name: 'naruto', average_score: 79 }]),\n        { status: 200 }\n      ],\n      [\n        JSON.stringify([{ name: 'bleach', average_score: 68 }]),\n        { status: 200 }\n      ],\n      [\n        JSON.stringify([{ name: 'one piece', average_score: 80 }]),\n        { status: 200 }\n      ],\n      [\n        JSON.stringify([{ name: 'shingeki', average_score: 91 }]),\n        { status: 200 }\n      ]\n    )\n\n    const expectedActions = [\n      {\n        type: 'FETCH_ANIMELIST_REQUEST'\n      },\n      {\n        type: 'SET_YEAR',\n        payload: {\n          animes: [\n            { name: 'naruto', average_score: 7.9 },\n            { name: 'bleach', average_score: 6.8 },\n            { name: 'one piece', average_score: 8 },\n            { name: 'shingeki', average_score: 9.1 }\n          ],\n          year: 2016\n        }\n      },\n      {\n        type: 'FETCH_ANIMELIST_COMPLETE'\n      }\n    ]\n    const store = mockStore({\n      config: {\n        token: { access_token: 'wtw45CmyEuh4P621IDVxWkgVr5QwTg3wXEc4Z7Cv' }\n      },\n      years: []\n    })\n\n    return (\n      store\n        .dispatch(getYear(2016))\n        //This calls fetch 4 times, once for each season\n        .then(() => {\n          // return of async actions\n          expect(store.getActions()).toEqual(expectedActions)\n        })\n    )\n  })\n})\n```\n\n### Reset mocks between tests with `fetch.resetMocks`\n\n`fetch.resetMocks` resets the `fetch` mock to give fresh mock data in between tests. It only resets the `fetch` calls as to not disturb any other mocked functionality.\n\n```js\ndescribe('getYear action creator', () => {\n  beforeEach(() => {\n      fetch.resetMocks();\n  });\n  it('dispatches the correct actions on successful getSeason fetch request', () => {\n\n    fetch.mockResponses(\n      [\n        JSON.stringify([ {name: 'naruto', average_score: 79} ]), { status: 200}\n      ],\n      [\n        JSON.stringify([ {name: 'bleach', average_score: 68} ]), { status: 200}\n      ]\n    )\n\n    const expectedActions = [\n      {\n        type: 'FETCH_ANIMELIST_REQUEST'\n      },\n      {\n        type: 'SET_YEAR',\n        payload: {\n          animes: [\n            {name: 'naruto', average_score: 7.9},\n            {name: 'bleach', average_score: 6.8}\n          ],\n          year: 2016,\n        }\n      },\n      {\n        type: 'FETCH_ANIMELIST_COMPLETE'\n      }\n    ]\n    const store = mockStore({\n      config: { token: { access_token: 'wtw45CmyEuh4P621IDVxWkgVr5QwTg3wXEc4Z7Cv' }},\n      years: []\n    })\n\n    return store.dispatch(getYear(2016))\n      //This calls fetch 2 times, once for each season\n      .then(() => { // return of async actions\n        expect(store.getActions()).toEqual(expectedActions)\n      })\n  });\n  it('dispatches the correct actions on successful getSeason fetch request', () => {\n\n    fetch.mockResponses(\n      [\n        JSON.stringify([ {name: 'bleach', average_score: 68} ]), { status: 200}\n      ],\n      [\n        JSON.stringify([ {name: 'one piece', average_score: 80} ]), { status: 200}\n      ],\n      [\n        JSON.stringify([ {name: 'shingeki', average_score: 91} ]), { status: 200}\n      ]\n    )\n\n    const expectedActions = [\n      {\n        type: 'FETCH_ANIMELIST_REQUEST'\n      },\n      {\n        type: 'SET_YEAR',\n        payload: {\n          animes: [\n            {name: 'bleach', average_score: 6.8},\n            {name: 'one piece', average_score: 8},\n            {name: 'shingeki', average_score: 9.1}\n          ],\n          year: 2016,\n        }\n      },\n      {\n        type: 'FETCH_ANIMELIST_COMPLETE'\n      }\n    ]\n    const store = mockStore({\n      config: { token: { access_token: 'wtw45CmyEuh4P621IDVxWkgVr5QwTg3wXEc4Z7Cv' }},\n      years: []\n    })\n\n    return store.dispatch(getYear(2016))\n      //This calls fetch 3 times, once for each season\n      .then(() => { // return of async actions\n        expect(store.getActions()).toEqual(expectedActions)\n      })\n      ,\n\n  })\n})\n```\n\n### Using `fetch.mock` to inspect the mock state of each fetch call\n\n`fetch.mock` by default uses [Jest's mocking functions](https://facebook.github.io/jest/docs/en/mock-functions.html#mock-property). Therefore you can make assertions on the mock state. In this example we have an arbitrary function that makes a different fetch request based on the argument you pass to it. In our test, we run Jest's `beforeEach()` and make sure to reset our mock before each `it()` block as we will make assertions on the arguments we are passing to `fetch()`. The most uses property is the `fetch.mock.calls` array. It can give you information on each call, and their arguments which you can use for your `expect()` calls. Jest also comes with some nice aliases for the most used ones.\n\n```js\n// api.js\n\nimport 'cross-fetch'\n\nexport function APIRequest(who) {\n  if (who === 'facebook') {\n    return fetch('https://facebook.com')\n  } else if (who === 'twitter') {\n    return fetch('https://twitter.com')\n  } else {\n    return fetch('https://google.com')\n  }\n}\n```\n\n```js\n// api.test.js\nimport { APIRequest } from './api'\n\ndescribe('testing api', () => {\n  beforeEach(() => {\n    fetch.resetMocks()\n  })\n\n  it('calls google by default', () => {\n    fetch.mockResponse(JSON.stringify({ secret_data: '12345' }))\n    APIRequest()\n\n    expect(fetch.mock.calls.length).toEqual(1)\n    expect(fetch.mock.calls[0][0]).toEqual('https://google.com')\n  })\n\n  it('calls facebook', () => {\n    fetch.mockResponse(JSON.stringify({ secret_data: '12345' }))\n    APIRequest('facebook')\n\n    expect(fetch.mock.calls.length).toEqual(2)\n    expect(fetch.mock.calls[0][0]).toEqual(\n      'https://facebook.com/someOtherResource'\n    )\n    expect(fetch.mock.calls[1][0]).toEqual('https://facebook.com')\n  })\n\n  it('calls twitter', () => {\n    fetch.mockResponse(JSON.stringify({ secret_data: '12345' }))\n    APIRequest('twitter')\n\n    expect(fetch).toBeCalled() // alias for expect(fetch.mock.calls.length).toEqual(1);\n    expect(fetch).toBeCalledWith('https://twitter.com') // alias for expect(fetch.mock.calls[0][0]).toEqual();\n  })\n})\n```\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017 Jeff Lau\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/jest-fetch-mock/-/jest-fetch-mock-1.7.5.tgz#ae0d01db1f6cbe95da1f283351c6c4de96264c67",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/jest-fetch-mock/-/jest-fetch-mock-1.7.5.tgz",
    "hash": "ae0d01db1f6cbe95da1f283351c6c4de96264c67",
    "integrity": "sha512-fP0CXb24z5oyvHiqakvDiDqEik1LPmIgRqsrqLhXkMNqSfibfsDkP5VJzm9/rmVsT9WSGQGNZ4iD2f1/Sm0qmg==",
    "registry": "npm",
    "packageName": "jest-fetch-mock"
  },
  "registry": "npm",
  "hash": "ae0d01db1f6cbe95da1f283351c6c4de96264c67"
}